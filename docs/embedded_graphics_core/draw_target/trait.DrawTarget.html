<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A target for embedded-graphics drawing operations."><title>DrawTarget in embedded_graphics_core::draw_target - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-4e54bb2b497cc83f.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="embedded_graphics_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0-nightly (139fb2214 2024-01-03)" data-channel="nightly" data-search-js="search-c17e98913a53b3b7.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-0b2e2def73e61cbe.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../embedded_graphics_core/index.html"><img src="https://raw.githubusercontent.com/embedded-graphics/embedded-graphics/b225511f390c0ed9bc065eb67d05125845312148/assets/logo_core.svg?sanitize=true" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../embedded_graphics_core/index.html"><img src="https://raw.githubusercontent.com/embedded-graphics/embedded-graphics/b225511f390c0ed9bc065eb67d05125845312148/assets/logo_core.svg?sanitize=true" alt="logo"></a><h2><a href="../../embedded_graphics_core/index.html">embedded_graphics_core</a><span class="version">0.4.0</span></h2></div><h2 class="location"><a href="#">DrawTarget</a></h2><div class="sidebar-elems"><section><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.Color">Color</a></li><li><a href="#associatedtype.Error">Error</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.draw_iter">draw_iter</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.clear">clear</a></li><li><a href="#method.fill_contiguous">fill_contiguous</a></li><li><a href="#method.fill_solid">fill_solid</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In embedded_graphics_core::draw_target</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../embedded_graphics_core/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../index.html">embedded_graphics_core</a>::<wbr><a href="index.html">draw_target</a>::<wbr><a class="trait" href="#">DrawTarget</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/embedded_graphics_core/draw_target/mod.rs.html#281-425">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait DrawTarget: <a class="trait" href="../geometry/trait.Dimensions.html" title="trait embedded_graphics_core::geometry::Dimensions">Dimensions</a> {
    type <a href="#associatedtype.Color" class="associatedtype">Color</a>: <a class="trait" href="../pixelcolor/trait.PixelColor.html" title="trait embedded_graphics_core::pixelcolor::PixelColor">PixelColor</a>;
    type <a href="#associatedtype.Error" class="associatedtype">Error</a>;

    // Required method
    fn <a href="#tymethod.draw_iter" class="fn">draw_iter</a>&lt;I&gt;(&amp;mut self, pixels: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Error" title="type embedded_graphics_core::draw_target::DrawTarget::Error">Error</a>&gt;
       <span class="where">where I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="../struct.Pixel.html" title="struct embedded_graphics_core::Pixel">Pixel</a>&lt;Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type embedded_graphics_core::draw_target::DrawTarget::Color">Color</a>&gt;&gt;</span>;

    // Provided methods
    fn <a href="#method.fill_contiguous" class="fn">fill_contiguous</a>&lt;I&gt;(
        &amp;mut self,
        area: &amp;<a class="struct" href="../primitives/rectangle/struct.Rectangle.html" title="struct embedded_graphics_core::primitives::rectangle::Rectangle">Rectangle</a>,
        colors: I
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Error" title="type embedded_graphics_core::draw_target::DrawTarget::Error">Error</a>&gt;
       <span class="where">where I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type embedded_graphics_core::draw_target::DrawTarget::Color">Color</a>&gt;</span> { ... }
<span class="item-spacer"></span>    fn <a href="#method.fill_solid" class="fn">fill_solid</a>(
        &amp;mut self,
        area: &amp;<a class="struct" href="../primitives/rectangle/struct.Rectangle.html" title="struct embedded_graphics_core::primitives::rectangle::Rectangle">Rectangle</a>,
        color: Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type embedded_graphics_core::draw_target::DrawTarget::Color">Color</a>
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Error" title="type embedded_graphics_core::draw_target::DrawTarget::Error">Error</a>&gt; { ... }
<span class="item-spacer"></span>    fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self, color: Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type embedded_graphics_core::draw_target::DrawTarget::Color">Color</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Error" title="type embedded_graphics_core::draw_target::DrawTarget::Error">Error</a>&gt; { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A target for embedded-graphics drawing operations.</p>
<p>The <code>DrawTarget</code> trait is used to add embedded-graphics support to a display
driver or similar targets like framebuffers or image files.
Targets are required to at least implement the <a href="trait.DrawTarget.html#tymethod.draw_iter" title="method embedded_graphics_core::draw_target::DrawTarget::draw_iter"><code>draw_iter</code></a> method and the <a href="../geometry/trait.Dimensions.html" title="trait embedded_graphics_core::geometry::Dimensions"><code>Dimensions</code></a>
trait. All other methods provide default implementations which use these methods internally.</p>
<p>Because the default implementations cannot use features specific to the target hardware they
can be overridden to improve performance. These target specific implementations might, for
example, use hardware accelerated drawing operations provided by a display controller or
specialized hardware modules in a microcontroller.</p>
<p>Note that some displays require a “flush” operation to write changes from a framebuffer to the
display. See docs associated with the chosen display driver for details on how to update the
display.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2><h3 id="minimum-implementation"><a href="#minimum-implementation">Minimum implementation</a></h3>
<p>In this example <code>DrawTarget</code> is implemented for an an imaginary 64px x 64px 8-bit grayscale display
that is connected using a simplified SPI interface. Because the hardware doesn’t support any
acceleration only the <a href="trait.DrawTarget.html#tymethod.draw_iter" title="method embedded_graphics_core::draw_target::DrawTarget::draw_iter"><code>draw_iter</code></a> method and <a href="../geometry/trait.OriginDimensions.html" title="trait embedded_graphics_core::geometry::OriginDimensions"><code>OriginDimensions</code></a> trait need to be implemented.</p>
<p>To reduce the overhead caused by communicating with the display for each drawing operation
the display driver uses and framebuffer to store the pixel data in memory. This way all drawing
operations can be executed in local memory and the actual display is only updated on demand
by calling the <code>flush</code> method.</p>
<p>Because all drawing operations are using a local framebuffer no communication error can occur
while they are executed and the <a href="trait.DrawTarget.html#associatedtype.Error" title="associated type embedded_graphics_core::draw_target::DrawTarget::Error"><code>Error</code> type</a> can be set to <code>core::convert::Infallible</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::convert::TryInto;
<span class="kw">use </span>embedded_graphics::{
    pixelcolor::{Gray8, GrayColor},
    prelude::<span class="kw-2">*</span>,
    primitives::{Circle, PrimitiveStyle},
};

<span class="doccomment">/// SPI communication error
</span><span class="attr">#[derive(Debug)]
</span><span class="kw">struct </span>CommError;

<span class="doccomment">/// A fake 64px x 64px display.
</span><span class="kw">struct </span>ExampleDisplay {
    <span class="doccomment">/// The framebuffer with one `u8` value per pixel.
    </span>framebuffer: [u8; <span class="number">64 </span>* <span class="number">64</span>],

    <span class="doccomment">/// The interface to the display controller.
    </span>iface: SPI1,
}

<span class="kw">impl </span>ExampleDisplay {
    <span class="doccomment">/// Updates the display from the framebuffer.
    </span><span class="kw">pub fn </span>flush(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;(), CommError&gt; {
        <span class="self">self</span>.iface.send_bytes(<span class="kw-2">&amp;</span><span class="self">self</span>.framebuffer)
    }
}

<span class="kw">impl </span>DrawTarget <span class="kw">for </span>ExampleDisplay {
    <span class="kw">type </span>Color = Gray8;
    <span class="comment">// `ExampleDisplay` uses a framebuffer and doesn't need to communicate with the display
    // controller to draw pixel, which means that drawing operations can never fail. To reflect
    // this the type `Infallible` was chosen as the `Error` type.
    </span><span class="kw">type </span>Error = core::convert::Infallible;

    <span class="kw">fn </span>draw_iter&lt;I&gt;(<span class="kw-2">&amp;mut </span><span class="self">self</span>, pixels: I) -&gt; <span class="prelude-ty">Result</span>&lt;(), <span class="self">Self</span>::Error&gt;
    <span class="kw">where
        </span>I: IntoIterator&lt;Item = Pixel&lt;<span class="self">Self</span>::Color&gt;&gt;,
    {
        <span class="kw">for </span>Pixel(coord, color) <span class="kw">in </span>pixels.into_iter() {
            <span class="comment">// Check if the pixel coordinates are out of bounds (negative or greater than
            // (63,63)). `DrawTarget` implementation are required to discard any out of bounds
            // pixels without returning an error or causing a panic.
            </span><span class="kw">if let </span><span class="prelude-val">Ok</span>((x @ <span class="number">0</span>..=<span class="number">63</span>, y @ <span class="number">0</span>..=<span class="number">63</span>)) = coord.try_into() {
                <span class="comment">// Calculate the index in the framebuffer.
                </span><span class="kw">let </span>index: u32 = x + y * <span class="number">64</span>;
                <span class="self">self</span>.framebuffer[index <span class="kw">as </span>usize] = color.luma();
            }
        }

        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">impl </span>OriginDimensions <span class="kw">for </span>ExampleDisplay {
    <span class="kw">fn </span>size(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Size {
        Size::new(<span class="number">64</span>, <span class="number">64</span>)
    }
}

<span class="kw">let </span><span class="kw-2">mut </span>display = ExampleDisplay {
    framebuffer: [<span class="number">0</span>; <span class="number">4096</span>],
    iface: SPI1,
};

<span class="comment">// Draw a circle with top-left at `(22, 22)` with a diameter of `20` and a white stroke
</span><span class="kw">let </span>circle = Circle::new(Point::new(<span class="number">22</span>, <span class="number">22</span>), <span class="number">20</span>)
    .into_styled(PrimitiveStyle::with_stroke(Gray8::WHITE, <span class="number">1</span>));

circle.draw(<span class="kw-2">&amp;mut </span>display)<span class="question-mark">?</span>;

<span class="comment">// Update the display
</span>display.flush().unwrap();</code></pre></div>
<h2 id="hardware-acceleration---solid-rectangular-fill"><a href="#hardware-acceleration---solid-rectangular-fill">Hardware acceleration - solid rectangular fill</a></h2>
<p>This example uses an imaginary display with 16bpp RGB565 colors and hardware support for
filling of rectangular areas with a solid color. A real display controller that supports this
operation is the SSD1331 with it’s “Draw Rectangle” (<code>22h</code>) command which this example
is loosely based on.</p>
<p>To leverage this feature in a <code>DrawTarget</code>, the default implementation of <a href="trait.DrawTarget.html#method.fill_solid" title="method embedded_graphics_core::draw_target::DrawTarget::fill_solid"><code>fill_solid</code></a> can be
overridden by a custom implementation. Instead of drawing individual pixels, this target
specific version will only send a single command to the display controller in one transaction.
Because the command size is independent of the filled area, all <a href="trait.DrawTarget.html#method.fill_solid" title="method embedded_graphics_core::draw_target::DrawTarget::fill_solid"><code>fill_solid</code></a> calls will only
transmit 8 bytes to the display, which is far less then what is required to transmit each pixel
color inside the filled area.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::convert::TryInto;
<span class="kw">use </span>embedded_graphics::{
    pixelcolor::{raw::RawU16, Rgb565, RgbColor},
    prelude::<span class="kw-2">*</span>,
    primitives::{Circle, Rectangle, PrimitiveStyle, PrimitiveStyleBuilder},
};

<span class="doccomment">/// SPI communication error
</span><span class="attr">#[derive(Debug)]
</span><span class="kw">struct </span>CommError;

<span class="doccomment">/// An example display connected over SPI.
</span><span class="kw">struct </span>ExampleDisplay {
    iface: SPI1,
}

<span class="kw">impl </span>ExampleDisplay {
    <span class="doccomment">/// Send a single pixel to the display
    </span><span class="kw">pub fn </span>set_pixel(<span class="kw-2">&amp;</span><span class="self">self</span>, x: u32, y: u32, color: u16) -&gt; <span class="prelude-ty">Result</span>&lt;(), CommError&gt; {
        <span class="comment">// ...

        </span><span class="prelude-val">Ok</span>(())
    }

    <span class="doccomment">/// Send commands to the display
    </span><span class="kw">pub fn </span>send_commands(<span class="kw-2">&amp;</span><span class="self">self</span>, commands: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Result</span>&lt;(), CommError&gt; {
        <span class="comment">// Send data marked as commands to the display.

        </span><span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">impl </span>DrawTarget <span class="kw">for </span>ExampleDisplay {
    <span class="kw">type </span>Color = Rgb565;
    <span class="kw">type </span>Error = CommError;

    <span class="kw">fn </span>draw_iter&lt;I&gt;(<span class="kw-2">&amp;mut </span><span class="self">self</span>, pixels: I) -&gt; <span class="prelude-ty">Result</span>&lt;(), <span class="self">Self</span>::Error&gt;
    <span class="kw">where
        </span>I: IntoIterator&lt;Item = Pixel&lt;<span class="self">Self</span>::Color&gt;&gt;,
    {
        <span class="kw">for </span>Pixel(coord, color) <span class="kw">in </span>pixels.into_iter() {
            <span class="comment">// Check if the pixel coordinates are out of bounds (negative or greater than
            // (63,63)). `DrawTarget` implementation are required to discard any out of bounds
            // pixels without returning an error or causing a panic.
            </span><span class="kw">if let </span><span class="prelude-val">Ok</span>((x @ <span class="number">0</span>..=<span class="number">63</span>, y @ <span class="number">0</span>..=<span class="number">63</span>)) = coord.try_into() {
                <span class="self">self</span>.set_pixel(x, y, RawU16::from(color).into_inner())<span class="question-mark">?</span>;
            }
        }

        <span class="prelude-val">Ok</span>(())
    }

    <span class="kw">fn </span>fill_solid(<span class="kw-2">&amp;mut </span><span class="self">self</span>, area: <span class="kw-2">&amp;</span>Rectangle, color: <span class="self">Self</span>::Color) -&gt; <span class="prelude-ty">Result</span>&lt;(), <span class="self">Self</span>::Error&gt; {
        <span class="comment">// Clamp the rectangle coordinates to the valid range by determining
        // the intersection of the fill area and the visible display area
        // by using Rectangle::intersection.
        </span><span class="kw">let </span>area = area.intersection(<span class="kw-2">&amp;</span><span class="self">self</span>.bounding_box());

        <span class="comment">// Do not send a draw rectangle command if the intersection size if zero.
        // The size is checked by using `Rectangle::bottom_right`, which returns `None`
        // if the size is zero.
        </span><span class="kw">let </span>bottom_right = <span class="kw">if let </span><span class="prelude-val">Some</span>(bottom_right) = area.bottom_right() {
            bottom_right
        } <span class="kw">else </span>{
            <span class="kw">return </span><span class="prelude-val">Ok</span>(());
        };

        <span class="self">self</span>.send_commands(<span class="kw-2">&amp;</span>[
            <span class="comment">// Draw rectangle command
            </span><span class="number">0x22</span>,
            <span class="comment">// Top left X coordinate
            </span>area.top_left.x <span class="kw">as </span>u8,
            <span class="comment">// Top left Y coordinate
            </span>area.top_left.y <span class="kw">as </span>u8,
            <span class="comment">// Bottom right X coordinate
            </span>bottom_right.x <span class="kw">as </span>u8,
            <span class="comment">// Bottom right Y coordinate
            </span>bottom_right.y <span class="kw">as </span>u8,
            <span class="comment">// Fill color red channel
            </span>color.r(),
            <span class="comment">// Fill color green channel
            </span>color.g(),
            <span class="comment">// Fill color blue channel
            </span>color.b(),
        ])
    }
}

<span class="kw">impl </span>OriginDimensions <span class="kw">for </span>ExampleDisplay {
    <span class="kw">fn </span>size(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Size {
        Size::new(<span class="number">64</span>, <span class="number">64</span>)
    }
}

<span class="kw">let </span><span class="kw-2">mut </span>display = ExampleDisplay { iface: SPI1 };

<span class="comment">// Draw a rectangle with 5px red stroke and green fill.
// The stroke and fill can be broken down into multiple individual rectangles,
// so this uses `fill_solid` internally.
</span>Rectangle::new(Point::new(<span class="number">20</span>, <span class="number">20</span>), Size::new(<span class="number">50</span>, <span class="number">40</span>))
    .into_styled(
        PrimitiveStyleBuilder::new()
            .stroke_color(Rgb565::RED)
            .stroke_width(<span class="number">5</span>)
            .fill_color(Rgb565::GREEN)
            .build(),
    )
    .draw(<span class="kw-2">&amp;mut </span>display)<span class="question-mark">?</span>;

<span class="comment">// Draw a circle with top-left at `(5, 5)` with a diameter of `10` and a magenta stroke with
// cyan fill. This shape cannot be optimized by calls to `fill_solid` as it contains transparent
// pixels as well as pixels of different colors. It will instead delegate to `draw_iter`
// internally.
</span>Circle::new(Point::new(<span class="number">5</span>, <span class="number">5</span>), <span class="number">10</span>)
    .into_styled(
        PrimitiveStyleBuilder::new()
            .stroke_color(Rgb565::MAGENTA)
            .stroke_width(<span class="number">1</span>)
            .fill_color(Rgb565::CYAN)
            .build(),
    )
    .draw(<span class="kw-2">&amp;mut </span>display)<span class="question-mark">?</span>;
</code></pre></div>
</div></details><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedtype.Color" class="method"><a class="src rightside" href="../../src/embedded_graphics_core/draw_target/mod.rs.html#283">source</a><h4 class="code-header">type <a href="#associatedtype.Color" class="associatedtype">Color</a>: <a class="trait" href="../pixelcolor/trait.PixelColor.html" title="trait embedded_graphics_core::pixelcolor::PixelColor">PixelColor</a></h4></section></summary><div class="docblock"><p>The pixel color type the targetted display supports.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Error" class="method"><a class="src rightside" href="../../src/embedded_graphics_core/draw_target/mod.rs.html#294">source</a><h4 class="code-header">type <a href="#associatedtype.Error" class="associatedtype">Error</a></h4></section></summary><div class="docblock"><p>Error type to return when a drawing operation fails.</p>
<p>This error is returned if an error occurred during a drawing operation. This mainly applies
to drivers that need to communicate with the display for each drawing operation, where a
communication error can occur. For drivers that use an internal framebuffer where drawing
operations can never fail, <a href="https://doc.rust-lang.org/stable/core/convert/enum.Infallible.html"><code>core::convert::Infallible</code></a> can instead be used as the <code>Error</code>
type.</p>
</div></details></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.draw_iter" class="method"><a class="src rightside" href="../../src/embedded_graphics_core/draw_target/mod.rs.html#302-304">source</a><h4 class="code-header">fn <a href="#tymethod.draw_iter" class="fn">draw_iter</a>&lt;I&gt;(&amp;mut self, pixels: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Error" title="type embedded_graphics_core::draw_target::DrawTarget::Error">Error</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="struct" href="../struct.Pixel.html" title="struct embedded_graphics_core::Pixel">Pixel</a>&lt;Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type embedded_graphics_core::draw_target::DrawTarget::Color">Color</a>&gt;&gt;,</div></h4></section></summary><div class="docblock"><p>Draw individual pixels to the display without a defined order.</p>
<p>Due to the unordered nature of the pixel iterator, this method is likely to be the slowest
drawing method for a display that writes data to the hardware immediately. If possible, the
other methods in this trait should be implemented to improve performance when rendering
more contiguous pixel patterns.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.fill_contiguous" class="method"><a class="src rightside" href="../../src/embedded_graphics_core/draw_target/mod.rs.html#388-397">source</a><h4 class="code-header">fn <a href="#method.fill_contiguous" class="fn">fill_contiguous</a>&lt;I&gt;(
    &amp;mut self,
    area: &amp;<a class="struct" href="../primitives/rectangle/struct.Rectangle.html" title="struct embedded_graphics_core::primitives::rectangle::Rectangle">Rectangle</a>,
    colors: I
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Error" title="type embedded_graphics_core::draw_target::DrawTarget::Error">Error</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type embedded_graphics_core::draw_target::DrawTarget::Color">Color</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Fill a given area with an iterator providing a contiguous stream of pixel colors.</p>
<p>Use this method to fill an area with contiguous, non-transparent pixel colors. Pixel
coordinates are iterated over from the top left to the bottom right corner of the area in
row-first order. The provided iterator must provide pixel color values based on this
ordering to produce correct output.</p>
<p>As seen in the example below, the <a href="../primitives/trait.PointsIter.html#tymethod.points" title="method embedded_graphics_core::primitives::PointsIter::points"><code>PointsIter::points</code></a> method can be used to get an
iterator over all points in the provided area.</p>
<p>The provided iterator is not required to provide <code>width * height</code> pixels to completely fill
the area. In this case, <code>fill_contiguous</code> should return without error.</p>
<p>This method should not attempt to draw any pixels that fall outside the drawable area of the
target display. The <code>area</code> argument can be clipped to the drawable area using the
<a href="../primitives/rectangle/struct.Rectangle.html#method.intersection" title="method embedded_graphics_core::primitives::rectangle::Rectangle::intersection"><code>Rectangle::intersection</code></a> method.</p>
<p>The default implementation of this method delegates to <a href="trait.DrawTarget.html#tymethod.draw_iter" title="method embedded_graphics_core::draw_target::DrawTarget::draw_iter"><code>draw_iter</code></a>.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>This is an example implementation of <code>fill_contiguous</code> that delegates to <a href="trait.DrawTarget.html#tymethod.draw_iter" title="method embedded_graphics_core::draw_target::DrawTarget::draw_iter"><code>draw_iter</code></a>. This
delegation behaviour is undesirable in a real application as it will be as slow as the
default trait implementation, however is shown here for demonstration purposes.</p>
<p>The example demonstrates the usage of <a href="../primitives/rectangle/struct.Rectangle.html#method.intersection" title="method embedded_graphics_core::primitives::rectangle::Rectangle::intersection"><code>Rectangle::intersection</code></a> on the passed <code>area</code>
argument to only draw visible pixels. If there is no intersection between <code>area</code> and the
display area, no pixels will be drawn.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>embedded_graphics::{
    pixelcolor::{Gray8, GrayColor},
    prelude::<span class="kw-2">*</span>,
    primitives::{ContainsPoint, Rectangle},
};

<span class="kw">struct </span>ExampleDisplay;

<span class="kw">impl </span>DrawTarget <span class="kw">for </span>ExampleDisplay {
    <span class="kw">type </span>Color = Gray8;
    <span class="kw">type </span>Error = core::convert::Infallible;

    <span class="kw">fn </span>draw_iter&lt;I&gt;(<span class="kw-2">&amp;mut </span><span class="self">self</span>, pixels: I) -&gt; <span class="prelude-ty">Result</span>&lt;(), <span class="self">Self</span>::Error&gt;
    <span class="kw">where
        </span>I: IntoIterator&lt;Item = Pixel&lt;<span class="self">Self</span>::Color&gt;&gt;,
    {
        <span class="comment">// Draw pixels to the display

        </span><span class="prelude-val">Ok</span>(())
    }

    <span class="kw">fn </span>fill_contiguous&lt;I&gt;(<span class="kw-2">&amp;mut </span><span class="self">self</span>, area: <span class="kw-2">&amp;</span>Rectangle, colors: I) -&gt; <span class="prelude-ty">Result</span>&lt;(), <span class="self">Self</span>::Error&gt;
    <span class="kw">where
        </span>I: IntoIterator&lt;Item = <span class="self">Self</span>::Color&gt;,
    {
        <span class="comment">// Clamp area to drawable part of the display target
        </span><span class="kw">let </span>drawable_area = area.intersection(<span class="kw-2">&amp;</span><span class="self">self</span>.bounding_box());

        <span class="comment">// Check that there are visible pixels to be drawn
        </span><span class="kw">if </span>drawable_area.size != Size::zero() {
            <span class="self">self</span>.draw_iter(
                area.points()
                    .zip(colors)
                    .filter(|(pos, _color)| drawable_area.contains(<span class="kw-2">*</span>pos))
                    .map(|(pos, color)| Pixel(pos, color)),
            )
        } <span class="kw">else </span>{
            <span class="prelude-val">Ok</span>(())
        }
    }
}

<span class="kw">impl </span>OriginDimensions <span class="kw">for </span>ExampleDisplay {
    <span class="kw">fn </span>size(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Size {
        Size::new(<span class="number">64</span>, <span class="number">64</span>)
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fill_solid" class="method"><a class="src rightside" href="../../src/embedded_graphics_core/draw_target/mod.rs.html#407-409">source</a><h4 class="code-header">fn <a href="#method.fill_solid" class="fn">fill_solid</a>(
    &amp;mut self,
    area: &amp;<a class="struct" href="../primitives/rectangle/struct.Rectangle.html" title="struct embedded_graphics_core::primitives::rectangle::Rectangle">Rectangle</a>,
    color: Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type embedded_graphics_core::draw_target::DrawTarget::Color">Color</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Error" title="type embedded_graphics_core::draw_target::DrawTarget::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Fill a given area with a solid color.</p>
<p>If the target display provides optimized hardware commands for filling a rectangular area of
the display with a solid color, this method should be overridden to use those commands to
improve performance.</p>
<p>The default implementation of this method calls <a href="trait.DrawTarget.html#method.fill_contiguous" title="method embedded_graphics_core::draw_target::DrawTarget::fill_contiguous"><code>fill_contiguous</code></a>
with an iterator that repeats the given <code>color</code> for every point in <code>area</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><a class="src rightside" href="../../src/embedded_graphics_core/draw_target/mod.rs.html#422-424">source</a><h4 class="code-header">fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self, color: Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type embedded_graphics_core::draw_target::DrawTarget::Color">Color</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Error" title="type embedded_graphics_core::draw_target::DrawTarget::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Fill the entire display with a solid color.</p>
<p>If the target hardware supports a more optimized way of filling the entire display with a
solid color, this method should be overridden to use those commands.</p>
<p>The default implementation of this method delegates to <a href="trait.DrawTarget.html#method.fill_solid" title="method embedded_graphics_core::draw_target::DrawTarget::fill_solid"><code>fill_solid</code></a> to fill the
<a href="../geometry/trait.Dimensions.html#tymethod.bounding_box" title="method embedded_graphics_core::geometry::Dimensions::bounding_box"><code>bounding_box</code></a> returned by the <a href="../geometry/trait.Dimensions.html" title="trait embedded_graphics_core::geometry::Dimensions"><code>Dimensions</code></a> implementation.</p>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/nightly/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../trait.impl/embedded_graphics_core/draw_target/trait.DrawTarget.js" async></script></section></div></main></body></html>