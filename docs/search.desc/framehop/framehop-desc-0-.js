searchState.loadedDescShard("framehop", 0, "framehop\nA trait which lets you opt into allocation-free unwinding. …\nThe unwind cache for the targeted CPU architecture. This …\nThe unwinder cache for the native CPU architecture.\nStatistics about the effectiveness of the rule cache.\nThe error type used in this crate.\nExplicit addresses and data of various sections in the …\nAn absolute code address for a stack frame. Can either be …\nThis address is the instruction pointer / program counter. …\nAllow allocation during unwinding. This is one of the two …\nInformation about a module that is loaded in a process. …\nThe module type. This is an associated type because the …\nInformation about a module’s sections (and segments).\nRequire allocation-free unwinding. This is one of the two …\nThis is a return address, i.e. the address to which the …\nAn iterator for unwinding the entire stack, starting from …\nThe unwind registers type for the targeted CPU …\nThe unwind registers type for the native CPU architecture.\nUnwinder is the trait that each CPU architecture’s …\nThe unwinder type for the native CPU architecture.\nTypes for unwinding on the aarch64 CPU architecture.\nAdd a module that’s loaded in the profiled process. This …\nThe raw address (AVMA).\nThe address (AVMA) that should be used for lookup.\nReturn the base address stated in the module.\nThe image base address, as stated in the object. For …\nThe data of the <code>.debug_frame</code> section. The related address …\nThe data of the <code>__eh_frame</code> or <code>.eh_frame</code> section. This is …\nThe data of the <code>.eh_frame_hdr</code> section. This is used during …\nThe address range of the <code>.eh_frame_hdr</code> section. This is …\nThe address range of the <code>__eh_frame</code> or <code>.eh_frame</code> section. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>FrameAddress::InstructionPointer</code>.\nCreate a <code>FrameAddress::ReturnAddress</code>. This returns <code>None</code> if …\nThe address range of the <code>.got</code> section (Global Offset …\nThe number of successful cache hits.\nThe number of total hits.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this address is a return address.\nReturn an iterator that unwinds frame by frame until the …\nReturn an iterator that unwinds frame by frame until the …\nReturns the highest code address that is known in this …\nThe number of cache misses that were due to an empty slot.\nThe number of cache misses that were due to cache slot …\nThe number of cache misses that were due to a filled slot …\nThe number of total misses.\nCreate a new iterator. You’d usually use …\nCreate a new instance.\nYield the next frame in the stack.\nRemove a module that was added before using <code>add_module</code>, …\nGet the given section’s data. This will only be called …\nGet the given section’s memory range, as stated in the …\nGet the given segment’s data. This will only be called …\nGet the given segment’s data. This will only be called …\nGet the given segment’s memory range, as stated in the …\nGet the given segment’s memory range, as stated in the …\nThe address range of the mach-O <code>__stub_helper</code> section. …\nThe address range of the mach-O <code>__stubs</code> section. Contains …\nThe data of the <code>__text</code> or <code>.text</code> section. This is where …\nThe data of the <code>__TEXT</code> segment of mach-O binaries, if …\nThe address range of the <code>__TEXT</code> segment of mach-O …\nThe address range of the <code>__text</code> or <code>.text</code> section. This is …\nThe number of total lookups.\nUnwind a single frame, to recover return address and …\nThe data of the <code>__unwind_info</code> section of mach-O binaries.\nTypes for unwinding on the x86_64 CPU architecture.\nThe Aarch64 CPU architecture.\nThe unwinder cache type for <code>UnwinderAarch64</code>.\n(sp, fp, lr) = (sp, fp, lr) Only possible for the first …\n(sp, fp, lr) = if is_first_frame (sp, fp, lr) else (fp + …\n(sp, fp, lr) = (sp + 16x, fp, lr) Only possible for the …\n(sp, fp, lr) = (sp + 16x, *(sp + 8y), *(sp + 8z))\n(sp, fp, lr) = (sp + 16x, fp, *(sp + 8y))\n(sp, fp, lr) = (sp + 16x, fp, lr) if is_first_frame This …\nAarch64 CPUs support special instructions which interpret …\nThe registers used for unwinding on Aarch64. We only need …\nThe unwinder for the Aarch64 CPU architecture. Use the …\n(sp, fp, lr) = (fp + 16, *fp, *(fp + 8))\n(sp, fp, lr) = (fp + 8x, *(fp + 8y), *(fp + 8z))\nGet the frame pointer value (x29).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeduce a mask based on the highest known address. The …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the lr register value.\nGet the <code>PtrAuthMask</code> which we apply to the <code>lr</code> value.\nCreate a new cache.\nCreate an unwinder for a process.\nCreate a set of unwind register values and do not apply …\nCreate a mask for 24 bits hash + 40 bits pointer. This …\nCreate a new cache.\nCreate a no-op mask which treats all bits of the pointer …\nCreate a set of unwind register values with the given mask …\nSet the frame pointer value (x29).\nSet the lr register value.\nSet the stack pointer value.\nGet the stack pointer value.\nReturns a snapshot of the cache usage statistics.\nApply the mask to the given pointer.\nThe x86_64 CPU architecture.\nThe unwinder cache type for <code>UnwinderX86_64</code>.\n(sp, bp) = (sp + 8, bp)\n(sp, bp) = if is_first_frame (sp + 8, bp) else (bp + 16, *…\n(sp, bp) = (sp + 8x, bp)\n(sp, …) = (sp + 8 * (offset + register count), … …\n(sp, bp) = (sp + 8x, *(sp + 8y))\nFor all of these: return address is *(new_sp - 8)\nThe unwinder for the x86_64 CPU architecture. Use the …\n(sp, bp) = (bp + 16, *bp)\nGet the rule which represents the given operations, if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new cache.\nCreate an unwinder for a process.\nCreate a new cache.\nReturns a snapshot of the cache usage statistics.\nAn encoded ordering of the callee-save registers to pop …\nThe number of registers to pop from the stack.\nThe additional stack pointer offset to undo before popping …")