<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="“Fallible” iterators."><title>fallible_iterator - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="fallible_iterator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0-nightly (a7a1618e6 2025-07-22)" data-channel="nightly" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-673ee1e0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../fallible_iterator/index.html">fallible_<wbr>iterator</a><span class="version">0.3.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#fallible-closure-arguments" title="Fallible closure arguments">Fallible closure arguments</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>fallible_iterator</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/fallible_iterator/lib.rs.html#1-2808">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>“Fallible” iterators.</p>
<p>The iterator APIs in the Rust standard library do not support iteration
that can fail in a first class manner. These iterators are typically modeled
as iterating over <code>Result&lt;T, E&gt;</code> values; for example, the <code>Lines</code> iterator
returns <code>io::Result&lt;String&gt;</code>s. When simply iterating over these types, the
value being iterated over must be unwrapped in some way before it can be
used:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">for </span>line <span class="kw">in </span>reader.lines() {
    <span class="kw">let </span>line = line<span class="question-mark">?</span>;
    <span class="comment">// work with line
</span>}</code></pre></div>
<p>In addition, many of the additional methods on the <code>Iterator</code> trait will
not behave properly in the presence of errors when working with these kinds
of iterators. For example, if one wanted to count the number of lines of
text in a <code>Read</code>er, this might be a way to go about it:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>count = reader.lines().count();</code></pre></div>
<p>This will return the proper value when the reader operates successfully, but
if it encounters an IO error, the result will either be slightly higher than
expected if the error is transient, or it may run forever if the error is
returned repeatedly!</p>
<p>In contrast, a fallible iterator is built around the concept that a call to
<code>next</code> can fail. The trait has an additional <code>Error</code> associated type in
addition to the <code>Item</code> type, and <code>next</code> returns <code>Result&lt;Option&lt;Self::Item&gt;, Self::Error&gt;</code> rather than <code>Option&lt;Self::Item&gt;</code>. Methods like <code>count</code> return
<code>Result</code>s as well.</p>
<p>This does mean that fallible iterators are incompatible with Rust’s <code>for</code>
loop syntax, but <code>while let</code> loops offer a similar level of ergonomics:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">while let </span><span class="prelude-val">Some</span>(item) = iter.next()<span class="question-mark">? </span>{
    <span class="comment">// work with item
</span>}</code></pre></div>
<h3 id="fallible-closure-arguments"><a class="doc-anchor" href="#fallible-closure-arguments">§</a>Fallible closure arguments</h3>
<p>Like <code>Iterator</code>, many <code>FallibleIterator</code> methods take closures as arguments.
These use the same signatures as their <code>Iterator</code> counterparts, except that
<code>FallibleIterator</code> expects the closures to be fallible: they return
<code>Result&lt;T, Self::Error&gt;</code> instead of simply <code>T</code>.</p>
<p>For example, the standard library’s <code>Iterator::filter</code> adapter method
filters the underlying iterator according to a predicate provided by the
user, whose return type is <code>bool</code>. In <code>FallibleIterator::filter</code>, however,
the predicate returns <code>Result&lt;bool, Self::Error&gt;</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>numbers = convert(<span class="string">"100\n200\nfern\n400"</span>.lines().map(<span class="prelude-val">Ok</span>::&lt;<span class="kw-2">&amp;</span>str, Box&lt;Error&gt;&gt;));
<span class="kw">let </span>big_numbers = numbers.filter(|n| <span class="prelude-val">Ok</span>(u64::from_str(n)<span class="question-mark">? </span>&gt; <span class="number">100</span>));
<span class="macro">assert!</span>(big_numbers.count().is_err());</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Chain.html" title="struct fallible_iterator::Chain">Chain</a></dt><dd>An iterator which yields the elements of one iterator followed by another.</dd><dt><a class="struct" href="struct.Cloned.html" title="struct fallible_iterator::Cloned">Cloned</a></dt><dd>An iterator which clones the elements of the underlying iterator.</dd><dt><a class="struct" href="struct.Convert.html" title="struct fallible_iterator::Convert">Convert</a></dt><dd>A fallible iterator that wraps a normal iterator over <code>Result</code>s.</dd><dt><a class="struct" href="struct.Cycle.html" title="struct fallible_iterator::Cycle">Cycle</a></dt><dd>An iterator which cycles another endlessly.</dd><dt><a class="struct" href="struct.Empty.html" title="struct fallible_iterator::Empty">Empty</a></dt><dd>An iterator that yields nothing.</dd><dt><a class="struct" href="struct.Enumerate.html" title="struct fallible_iterator::Enumerate">Enumerate</a></dt><dd>An iterator that yields the iteration count as well as the values of the
underlying iterator.</dd><dt><a class="struct" href="struct.Filter.html" title="struct fallible_iterator::Filter">Filter</a></dt><dd>An iterator which uses a fallible predicate to determine which values of the
underlying iterator should be yielded.</dd><dt><a class="struct" href="struct.FilterMap.html" title="struct fallible_iterator::FilterMap">Filter<wbr>Map</a></dt><dd>An iterator which both filters and maps the values of the underlying
iterator.</dd><dt><a class="struct" href="struct.FlatMap.html" title="struct fallible_iterator::FlatMap">FlatMap</a></dt><dd>An iterator which maps each element to another iterator, yielding those iterator’s elements.</dd><dt><a class="struct" href="struct.Flatten.html" title="struct fallible_iterator::Flatten">Flatten</a></dt><dd>An iterator which flattens an iterator of iterators, yielding those iterators’ elements.</dd><dt><a class="struct" href="struct.FromFn.html" title="struct fallible_iterator::FromFn">FromFn</a></dt><dd>An iterator using a function to generate new values.</dd><dt><a class="struct" href="struct.Fuse.html" title="struct fallible_iterator::Fuse">Fuse</a></dt><dd>An iterator that yields <code>Ok(None)</code> forever after the underlying iterator
yields <code>Ok(None)</code> once.</dd><dt><a class="struct" href="struct.Inspect.html" title="struct fallible_iterator::Inspect">Inspect</a></dt><dd>An iterator which passes each element to a closure before returning it.</dd><dt><a class="struct" href="struct.IntoFallible.html" title="struct fallible_iterator::IntoFallible">Into<wbr>Fallible</a></dt><dd>A fallible iterator that wraps a normal iterator over <code>Result</code>s.</dd><dt><a class="struct" href="struct.Iterator.html" title="struct fallible_iterator::Iterator">Iterator</a></dt><dd>A normal (non-fallible) iterator which wraps a fallible iterator.</dd><dt><a class="struct" href="struct.Map.html" title="struct fallible_iterator::Map">Map</a></dt><dd>An iterator which applies a fallible transform to the elements of the
underlying iterator.</dd><dt><a class="struct" href="struct.MapErr.html" title="struct fallible_iterator::MapErr">MapErr</a></dt><dd>An iterator which applies a transform to the errors of the underlying
iterator.</dd><dt><a class="struct" href="struct.Once.html" title="struct fallible_iterator::Once">Once</a></dt><dd>An iterator that yields something exactly once.</dd><dt><a class="struct" href="struct.OnceErr.html" title="struct fallible_iterator::OnceErr">OnceErr</a></dt><dd>An iterator that fails with a predetermined error exactly once.</dd><dt><a class="struct" href="struct.Peekable.html" title="struct fallible_iterator::Peekable">Peekable</a></dt><dd>An iterator which can look at the next element without consuming it.</dd><dt><a class="struct" href="struct.Repeat.html" title="struct fallible_iterator::Repeat">Repeat</a></dt><dd>An iterator that endlessly repeats a single element.</dd><dt><a class="struct" href="struct.RepeatErr.html" title="struct fallible_iterator::RepeatErr">Repeat<wbr>Err</a></dt><dd>An iterator that endlessly repeats a single error.</dd><dt><a class="struct" href="struct.Rev.html" title="struct fallible_iterator::Rev">Rev</a></dt><dd>An iterator which yields elements of the underlying iterator in reverse
order.</dd><dt><a class="struct" href="struct.Scan.html" title="struct fallible_iterator::Scan">Scan</a></dt><dd>An iterator which applies a stateful closure.</dd><dt><a class="struct" href="struct.Skip.html" title="struct fallible_iterator::Skip">Skip</a></dt><dd>An iterator which skips initial elements.</dd><dt><a class="struct" href="struct.SkipWhile.html" title="struct fallible_iterator::SkipWhile">Skip<wbr>While</a></dt><dd>An iterator which skips initial elements based on a predicate.</dd><dt><a class="struct" href="struct.StepBy.html" title="struct fallible_iterator::StepBy">StepBy</a></dt><dd>An iterator which steps through the elements of the underlying iterator by a certain amount.</dd><dt><a class="struct" href="struct.Take.html" title="struct fallible_iterator::Take">Take</a></dt><dd>An iterator which yields a limited number of elements from the underlying
iterator.</dd><dt><a class="struct" href="struct.TakeWhile.html" title="struct fallible_iterator::TakeWhile">Take<wbr>While</a></dt><dd>An iterator which yields elements based on a predicate.</dd><dt><a class="struct" href="struct.Unwrap.html" title="struct fallible_iterator::Unwrap">Unwrap</a></dt><dd>An iterator that unwraps every element yielded by the underlying
FallibleIterator</dd><dt><a class="struct" href="struct.Zip.html" title="struct fallible_iterator::Zip">Zip</a></dt><dd>An iterator that yields pairs of this iterator’s and another iterator’s
values.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.DoubleEndedFallibleIterator.html" title="trait fallible_iterator::DoubleEndedFallibleIterator">Double<wbr>Ended<wbr>Fallible<wbr>Iterator</a></dt><dd>A fallible iterator able to yield elements from both ends.</dd><dt><a class="trait" href="trait.FallibleIterator.html" title="trait fallible_iterator::FallibleIterator">Fallible<wbr>Iterator</a></dt><dd>An <code>Iterator</code>-like trait that allows for calculation of items to fail.</dd><dt><a class="trait" href="trait.IntoFallibleIterator.html" title="trait fallible_iterator::IntoFallibleIterator">Into<wbr>Fallible<wbr>Iterator</a></dt><dd>Conversion into a <code>FallibleIterator</code>.</dd><dt><a class="trait" href="trait.IteratorExt.html" title="trait fallible_iterator::IteratorExt">Iterator<wbr>Ext</a></dt><dd>An extnsion-trait with set of useful methods to convert <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>core::iter::Iterator</code></a>
into <a href="trait.FallibleIterator.html" title="trait fallible_iterator::FallibleIterator"><code>FallibleIterator</code></a></dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.convert.html" title="fn fallible_iterator::convert">convert</a></dt><dd>Converts an <code>Iterator&lt;Item = Result&lt;T, E&gt;&gt;</code> into a <code>FallibleIterator&lt;Item = T, Error = E&gt;</code>.</dd><dt><a class="fn" href="fn.empty.html" title="fn fallible_iterator::empty">empty</a></dt><dd>Creates an iterator that yields nothing.</dd><dt><a class="fn" href="fn.from_fn.html" title="fn fallible_iterator::from_fn">from_fn</a></dt><dd>Creates an iterator from a fallible function generating values.</dd><dt><a class="fn" href="fn.once.html" title="fn fallible_iterator::once">once</a></dt><dd>Creates an iterator that yields an element exactly once.</dd><dt><a class="fn" href="fn.once_err.html" title="fn fallible_iterator::once_err">once_<wbr>err</a></dt><dd>Creates an iterator that fails with a predetermined error exactly once.</dd><dt><a class="fn" href="fn.repeat.html" title="fn fallible_iterator::repeat">repeat</a></dt><dd>Creates an iterator that endlessly repeats a single element.</dd><dt><a class="fn" href="fn.repeat_err.html" title="fn fallible_iterator::repeat_err">repeat_<wbr>err</a></dt><dd>Creates an iterator that endlessly repeats a single error.</dd></dl></section></div></main></body></html>